---
title: PHP的设计模式之架构模式（二）
urlname: php-structural-design-patterns-part2
date: 2018-04-03 16:03:46
category: 设计模式
tags: design-patterns
---
原文链接：[https://www.imooc.com/article/17276](https://www.imooc.com/article/17276)

## Structural Patterns（架构模式）
#### Bridge（桥接模式）
将抽象与实现解耦，使得两者可以独立的变化

为什么需要桥接模式

1. 如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。

2. 抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。

3. 虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。

例子：
如果我现在是小米公司的雷布斯，小米公司旗下有小米mix和小米note手机，现在有一个底层的语音输出软件，由于小米mix的全面屏设计没有开孔使用了骨传导，所以和小米note有些不同。那么我们要如何来设计这个输出功能呢？
<!-- more -->
传统的做法就应该是，一个抽象手机品牌，mix和note手机品牌继承抽象手机品牌。然后有一个mix品牌的输出软件继承自mix品牌。如果这时候有一个redmi的牌子的输出软件就应继承自redmi品牌，redmi继承抽象手机品牌。

如果除了这个语音输出软件，我们还有其它的软件呢，一个手机有很多软件，那么这种继承，如果画出继承链的话，那一个品牌下得有多少子类？

如果我们使用桥接模式的话，就可以把这个软件的具体实现与抽象品牌分离出来，这样也能是我们动态增减实现化角色时更为方便。
```php
<?php 
//抽象化角色 
abstract class MiPhone{
    protected $_audio;
    //存放音频软件对象
    abstract function output();
    public function __construct(Audio $audio){
        $this->_audio = $audio;
    }
} 
//具体手机
class Mix extends MiPhone{ 
    //语音输出功能
    public function output(){
        $this->_audio->output();
    }
} 
class Note extends MiPhone{
    public function output(){
        $this->_audio->output();
    }
} 
//实现化角色 功能实现者
abstract class Audio{
    abstract function output();
} 
//具体音频实现者 -骨传导音频输出
class Osteophony extends Audio{
    public function output(){
        echo "骨传导输出的声音-----哈哈".PHP_EOL;
    }
} 
//普通音频输出---声筒输出
class Cylinder extends Audio{
    public function output(){
        echo "声筒输出的声音-----呵呵".PHP_EOL;
    }
} 
//让小米mix和小米note输出声音
$mix = new Mix(new Osteophony);
$mix->output();
$note = new Note(new Cylinder);
$note->output();
```
这样写的好处是把抽象化角色手机和实现化角色手机的具体功能音频输出 分离了出来。如果现在最新的小米note系列也要用上骨传导输出，那么我们只需实例化时传入的声筒音频类改为骨传导音频类。如果我们还有一个扬声器输出，小米mix和小米note都有这个功能。我们只需要再添加一个扬声器输出类继承Audio类，然后谁使用就保存这个实例在属性中。没有桥接模式的话，我们可是要写两个，一个是小米mix的扬声器输出，一个是小米note。

如果扬声器输出对小米mix和小米note不一样，那么我们确实需要写两个扬声器输出类。使用桥接模式，依然比原来直接继承好，就是因为有一天扬声器技术驱动更新了，我们要更新扬声器不用修改手机类代码，而只需传入一个更新的扬声器类。
#### Proxy（代理模式）
构建了透明置于两个不同对象之内的一个对象，从而能够截取或代理这两个对象间的通信或访问。

为什么需要代理模式

1. 远程代理，也就是为了一个对象在不同地址空间提供局部代表。隐藏一个对象存在于不同地址空间的事实。

2. 虚拟代理，根据需要来创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象。

3. 安全代理，用来控制真实对象的访问对象。

4. 智能指引，当调用真实对象的时候，代理处理一些事情。

#### Composite（组合模式）
将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。组合模式也叫合成模式，有时候又叫做部分-整体模式。

为什么需要组合模式

1. 使我们在树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素,从而使得客户程序与复杂元素的内部结构解耦。

2. 组合模式让你可以优化处理递归或分级数据结构。

#### Flyweight（享元模式）
池技术的重要实现方式，运用共享技术有效的支持大量的细粒度对象，用于减少创建对象的数量，以减少内存占用和提高性能。

为什么需要享元模式

1. 在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。

2. 系统有大量相似对象。

3. 需要缓冲池的场景。

享元模式在PHP中可能比较少遇，但在Java中常常有这种情况。就是代码产生了大量的对象，虽然使用完有释放，但是由于垃圾回收需要一定时间，导致内存被耗尽。PHP经常应用web编程，脚本执行时间很短（30秒）。所以很少遇见这种情况，甚至我们使用完变量，连unset()函数都不用调用，就等着脚步执行结束后，自动释放。但是如果你试过在cli模式下运行PHP脚本，做一些socket通信，发送邮件等长耗时或是多连接任务时，就难免会遇到这种情况。