---
title: 命令行、队列和任务调度
urlname: laravel-artisan-queue-and-task-scheduling
date: 2020-06-16 15:22:49
category: PHP框架
tags: laravel
---

Love,Death&Robots

The Lion,the Witch and the Wardrobe

Artisan,Queue Job and Task-Scheduling

<!-- more -->

## Artisan

新建一个预约已过期命令：

```
php artisan make:command ReserveExpired
```

命令结构如下

```php
namespace App\Console\Commands;

use Illuminate\Console\Command;
use Reserve;

class ReserveExpired extends Command
{
    protected $signature = 'reserve-expired';

    protected $description = 'change expired reserve state';

    public function handle()
    {
        $reserve = new Reserve();
        $reserve->updateStateWhenExpired();
    }
}
```

`signature` 属性是在使用时期望输入的命令，`description` 是命令的描述，`handle()` 是命令执行时调用的方法

#### 注册命令

在 *app/Console/Kernel* 中定义了手动加载的命令：

```php
protected $commands = [
    Commands\ReserveExpired::class,//修改已过期的预约的状态
    Commands\TestCommand::class//test
];
```

在下面的 `commands()` 方法中定义了自动加载命令的文件：

```php
protected function commands()
{
    require base_path('routes/console.php');
}
```

在这个 *routes/console.php* 中命令是以闭包形式执行的，并使用了 Artisan Facade：

```php
Artisan::command('reserve-expired', function ($project) {
    $this->info("Success");
});
```

#### 交互式输入

1. 获取输入
```php
$name = $this->ask('What is your name?');
$password = $this->secret('What is the password?');
```

2. 请求确认
```php
if ($this->confirm('Do you wish to continue?')) {
    //
}
```

3. 改变颜色
```php
$this->info('Success');
$this->error('Fail');
$this->line('Hello world');
```

#### 定义输入期望

在 `signature` 属性中定义期望用户输入的内容

- 花括号 `{}` 为必须
- 加问号 `{?}` 为可选
- 加等号 `{=xx}` 为带默认值的可选

```php
protected $signature = 'wechat-menu {type?} {officialType?}';
```

当输入不符合时，直接返回提示信息：
```php
$usageString
    = <<<USAGE
Usage: wechat-menu [options] [officialType]

       options         args: create/get
       officialType    args: one/two/three
USAGE;
$this->info($usageString);
```

## Queue

先了解配置文件 *config/queue.php*

```php
'default' => env('QUEUE_DRIVER', 'sync'),
'connections' => [
        'sync' => [
            'driver' => 'sync',
        ],
        'database' => [
            'driver' => 'database',
        ],
        //...
        'redis' => [
            'driver' => 'redis',
        ],
    ],
```

`default` 是队列系统默认使用的驱动，在连接时可以使用 `onConnection()` 方法将任务推到指定连接
`connections` 可以配置各种驱动的设置，如 Redis 等
`failed` 配置队列中的任务执行失败时，保存失败任务的库与表

这里以 `database` 驱动为例

```bash
# 生成jobs表
php artisan queue:table
# 生成failed_jobs表
php artisan queue:failed-table
php artisan migrate
```

这里有一点，生成 jobs 表的迁移文件中，`attempts` 字段是无符号 tinyint 类型的

我在一次任务重试次数过多时，会导致超出范围，修改成了 int

#### 创建任务

新建一个收款任务：

```
php artisan make:job ReceiveMoney
```

任务类的基本格式：

```php
class ReceiveMoney implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;
    public function __construct{}
    public function handle{}
}
```
其中它引用了 `SerializesModels` trait，可以优雅地序列化Eloquent

`hanle` 是任务被处理时调用的主方法

#### 分发任务

在你的逻辑（控制器、或自定义的逻辑层等等）中，使用 `dispatch` 辅助函数分发它：

```php
\App\Jobs\ReceiveMoney::dispatch($updateArray, $type);
```

>需要延迟执行时可以链式调用 `delay()` 方法

适当修改我们的 `ReceiveMoney` 任务类，让它接收传递进来的两个参数，并保存一条收支记录：

```php
protected $updateArray;
protected $type;

public function __construct($updateArray, $type)
{
    $this->updateArray = $updateArray;
    $this->type = $type;
}

public function handle() {
    $this->saveReceiptRecord($this->updateArray, $this->type);
}

protected function saveReceiptRecord($updateArray, $type)
{
    //do sth...
}
```

#### 运行队列

```bash
# 常驻
php artisan queue:work
# 或者运行一次
php artisan queue:work --once
```

#### 失败处理

所有失败任务会存到 `failed_jobs` 表中，可以用表格方式展示：

```
php artisan queue:failed
```

```bash
# 重试单个ID
php artisan queue:retry 1
# 重试全部
php artisan queue:retry all
# 删除单个ID
php artisan queue:forget 2
# 删除全部
php artisan queue:flush
```

## Task-Scheduling

在 *App\Console\Kernel* 中 `schedule()` 方法中定义所有调度任务

有如下几种方式：

1. Closure
```php
$schedule->call(function () {
    DB::table('should_delete')->delete();
})->daily();
```

2. Artisan
```php
// 以上面的ReserveExpired为例
$schedule->command('reserve-expired')->dailyAt('02:00');
```

3. Job
```php
// 以上面的ReceiveMoney为例
$schedule->job(new ReceiveMoney)->everyFiveMinutes();
```

4. Shell
```php
$schedule->exec('node /home/forge/script.js')->daily();
```

### 可用的时间限制

|方法|描述|
|-|-|
|->cron('* * * * * *');|在自定义的 Cron 时间表上执行该任务|
|->everyMinute();|每分钟执行一次任务|
|->everyFiveMinutes();|每五分钟执行一次任务|
|->everyTenMinutes();|每十分钟执行一次任务|
|->everyFifteenMinutes();|每十五分钟执行一次任务|
|->everyThirtyMinutes();|每半小时执行一次任务|
|->hourly();|每小时执行一次任务|
|->hourlyAt(17);|每小时的第 17 分钟执行一次任务|
|->daily();|每天午夜执行一次任务|
|->dailyAt('13:00');|每天的 13:00 执行一次任务|
|->twiceDaily(1, 13);|每天的 1:00 和 13:00 分别执行一次任务|
|->weekly();|每周执行一次任务|
|->monthly();|每月执行一次任务|
|->monthlyOn(4, '15:00');|在每个月的第四天的 15:00 执行一次任务|
|->quarterly();|每季度执行一次任务|
|->yearly();|每年执行一次任务|
|->timezone('America/New_York');|设置时区|
