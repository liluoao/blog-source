---
title: 设计模式的应用
date: 2019-12-16 14:58:00
urlname: use-design-patterns
tags: design-patterns
---

## 前言

PHP 的设计模式有 23 种之多，平时开发中使用比较多的可能是 `单例 Singleton` `适配器 Adapter` `工厂 Factory` `策略 Strategy` 等模式。下面讲一些平时自己碰到的模式。

<!-- more -->

## 模板方法 TemplateMethod

半年前有个任务是为认证中心部门制作一个 **API 统一框架**，技术选型是 Yaf 框架，原因是它的轻量级和速度快。但是正因为太过简略，开发拥有很大的自主性，需要制定一个统一的开发流程。

一般思路是需要一个控制器抽象基类直接继承 `Yaf\Controller_Abstract`，普通的控制器再继承基类。我们是用 `trait` 来把流程的模板脱离出控制器。

```php
use ApiTemplate;
```

在 *ApiTemplate* 中规定了流程：

```php
trait ApiTemplate
{
    protected $response;

    public final funtion runAction()
    {
        try {
            $this->setParams();
            $this->checkParams();
            $this->response = $this->exec();
            $this->checkResponse();
            $this->returnResponse();
        } catch (Exception $e) {
            $this->handleError($e);
        }
    }

    //用参数处理插件代替
    abstract function setParams();
    abstract function checkParams();
    //主方法
    abstract function exec();
    //用响应处理插件代替
    abstract function checkResponse();
    abstract function returnResponse();
    //统一错误处理
    abstract function handleError(Exception $e);
}
```

让开发们按约定设置好 *请求参数和响应的配置*，只需要关心逻辑处理并写在 `exec()` 中，请求时统一都转到 *xxx/run* 方法，整个流程就统一了。

## 状态模式 State

17 年在做订单系统时，设计的订单类简化后大致如下：

```php
class Order
{
    private $state;

    const UN_PAY_STATE = 0;
    const PAY_STATE = 1;
    const EVALUATE_STATE = 2;
    const FINISH_STATE = 3;

    public function handle()
    {
        switch ($this->state) {
            case self::UN_PAY_STATE:
                //客户新建订单，是未付款
                break;
            case self::PAY_STATE:
                //客户未付款，要收钱
                break;
            case self::EVALUATE_STATE:
                //客户已付款，要评价
                break;
            case self::FINISH_STATE:
                //客户已评价，订单完成
                break;
        }
    }
}
```

使用时可能是这样的，思路就是单独状态单独处理，手动设置状态，比较僵硬：

```php
$order = new Order();
$order->setState(Order::PAY_STATE);
$order->handle();
```

用状态模式替代的时，主要是状态类的设计，下面写个已付款状态的例子：

> State 接口规定了 `doAction(Order $order)`

```php
class PayState implements State
{
    const STATE = 1;

    public function doAction(Order $order)
    {
        if (self::STATE === $order->getCurrentState()) {
            //是这个状态（该收钱了）
        } else {
            //转向下一个状态（去评价）
            $order->setState(new EvaluateState());
            $order->handle();
        }
    }
}
```

原来的订单类中需要加上新属性： `$currentState`，存放当前状态，原来的 `$state` 属性存放的就不是值了，而是一个状态对象：

```php
class Order
{
    private $state;
    private $currentState;

    public function __construct()
    {
        $this->state = new UnPayState();
        $this->currentState = UnPayState::STATE;
    }

    public function handle()
    {
        $this->state->doAction($this);
    }
}
```
